\section{Classificação de Recursos}

Como descrito anteriormente, o \emph{uOS} tem como foco a adaptabilidade de serviços, em que cada serviço pertence a um determinado recurso. Desta forma, faz-se necessária uma maneira de classificar tais recursos imersos nos mais variados dispositivos presentes no \emph{smart space} e regidos pelo \emph{middleware}. Essa classificação facilitará o desenvolvimento de novos \emph{drivers} para futuras aplicações, pois tornará possivel a definição de interfaces pré-estabelecidas que representem classes de recursos. Outra vantagem decorrente é a possibilidade de seleção de recursos equivalentes, caso o provedor originalmente selecionado esteja indisponível.

Imagine, por exemplo, o caso em que uma aplicação necessita de um serviço de \emph{snapshot} presente em um recurso de câmera. Suponha também que, dentre os diversos dispositivos registrados na base do \emph{middleware}, existam dois que possuam o recurso requisitado:

<PENSAR NUMA REPRESENTAÇÃO MELHOR>
\begin{itemize}
	\item D1
	\\Serviços:
	\begin{itemize}
		\item \emph{snapshot}
		\item \emph{recorder}
	\end{itemize}
	\item D2
	\\Serviços:
	\begin{itemize}
		\item \emph{snapshot}
		\item \emph{streaming} de vídeo
	\end{itemize}
\end{itemize}

De posse dessas informações, cabe ao \emph{uOS} determinar qual o melhor recurso a ser oferecido ao aplicativo solicitante. Caso a primeira opção esteja indisponível por qualquer motivo, deve-se então buscar por outras alternativas que não a inicial. Dessa forma, torna-se necessário a seleção de um recurso que seja equivalente ao da primeira escolha. Entende-se por equivalente todo recurso que:

\begin{itemize}
	\item Pertença à mesma classe;
	\item Possua serviços equivalentes. Neste caso, tais serviços devem possuir o mesmo retorno e a mesma assinatura, ou seja, mesmos nome, quantidade, tipo e ordem de parâmetros.
\end{itemize}

----------------------------------------- REVER -----------------------------------------

<Ver se cabe falar isso no JSON>

Em um ambiente cujos dispositivos podem se movimentar livremente e seus recursos devem ser compartilhados de forma transparente ao usuário, torna-se necessário que cada dispositivo presente na rede possa se comunicar facilmente com os demais, independente de quais tecnologias, padrões ou protocolos tenham sido adotados. É fundamental que essa comunicação seja feita de forma tão rápida e confiável quanto possível, pois toda atividade do \emph{middleware} com seus clientes depende dela, inclusive o processo de classificação dos recursos disponíveis no \emph{smart space}, idéia central deste documento.

Definir uma classificação de recursos facilitará o desenvolvimento de aplicações para o \emph{uOS}, além de facilitar a escolha de recursos disponíveis no ambiente. Por exemplo, um usuário necessita de um recurso de câmera. Vamos supor que para o usuário seja indiferente se a câmera possua ou não \emph{flash}. Atualmente o \emph{uOS} trata uma câmera e uma câmera com \emph{flash} como recursos independentes, o que dificulta a escolha de determinado recurso. Se uma aplicação requisitar um serviço de câmera sem \emph{flash} e no ambiente só existirem câmeras com \emph{flash}, o \emph{middleware} não conseguirá prover esse tipo de seviço, pois para ele são recursos (\emph{drivers}) diferentes.

----------------------------------------- REVER -----------------------------------------

\subsection{Formas de classificação}

Existem duas formas principais de se realizar uma classificação de recursos:

\begin{itemize}
	\item Fixa: conjunto fixo de classificações não-relacionadas;
	\item Relacionada: estabelece relações entre os tipos básicos pré-definidos e suas especializações.
\end{itemize}

As classificações de forma relacionada possuem a vantagem de reutilizar atributos definidos em outras classes e de poder adicionar novos atributos especializando os tipos relacionados, o que evita redundância na definição das classes. Enquanto as classificações de forma Fixa possuem a vantagem de serem mais simples de serem definidas.

Uma importante propriedade de uma classificação é a hierarquia, ou seja, uma representação em que as categorias da classificação podem ser especializadas formando novas categorias mais específicas, com diferentes atributos. Existem diferentes maneiras conhecidas de se representar uma hierarquia de forma a relacionar categorias que tenham atributos em comum: arquivos no formato XML, hierarquia de classes, ontologia ou simplesmente não utilizar uma hierarquia onde as categorias não tem relações entre si, caso da forma fixa de classificação.

O XML (\emph{Extensible Markup Language}), como seu próprio nome sugere, pode ser estendido e dessa forma, é possível montar uma hierarquia de arquivos XML. O seu uso para descrever um tipo de dispositivo tem a vantagem de ser independente de plataformas de hardware ou software e, devido sua formatação, possui uma boa legibilidade, não necessitando de um pré-processamento por parte de um computador para seu conteúdo se tornar compreensível. Esse formato possui, contudo, a desvantagem de repetir uma grande quantidade de informação o que pode prejudicar a velocidade de comunicação entre dispositivos que o utilizem. Outro fator que deve ser levado em consideração é que o conjunto de protocolos \emph{uP} (\emph{Ubiquitous Protocols}) do \emph{middleware} \emph{uOS} utiliza o formato JSON para troca de mensagens, um mecanismo mais leve, e ainda assim estruturado, para representar informação.

A hierarquia de classes é amplamente utilizada na programação orientada à objetos. Uma classe possui atributos ou propriedades e uma outra classe pode herdar esses atributos e criar uma especialização dessa classe raiz, à esse relacionamento dá-se o nome de herança. Dependendo da linguagem utilizada, uma classe pode herdar métodos e atributos de várias outras classes, formando uma herança múltipla de classes, ou então poderá cada subclasse poderá herdar de apenas uma outra classe, não podendo, entretanto, ocorrer uma herança circular, onde uma classe A herda de uma classe B, que por sua vez herda atributos de uma classe C que especializa a classe A. Uma hierarquia de classes forma, portanto, uma espécie de árvore de classes.

Ontologia é uma descrição formal de conceitos (classes) em um determinado domínio. Esses conceitos possuem propriedades, que descrevem atributos, características e restrições. De forma semelhante à orientação à objetos, conceitos podem possuir subclasses que especializam a classe superior. A Ontologia já permite uma herança múltipla de classes, e novos conceitos podem ser construídos por meio do relacionamento entre classes. Para construir uma Ontologia deve-se definir as classes do domínio, distribuir as classes de forma hierárquica, definir valores e restrições para suas propriedades e utilizar esses valores nas instâncias das classes da Ontologia. 

\begin{comment}
Dessa forma, temos uma base de conhecimento. As Ontologias se tornaram populares na Web por dividir produtos em categorias e em características em sites de venda, e atualmente são utilizadas para compartilhar informação entre pessoas e agentes inteligentes. Uma antologia provê reutilização de conhecimento e torna explícitas as hipóteses sobre um domínio e análise do domínio.
\end{comment}


\subsection{Padrões}
%Apresentar os padrões. Focar nas classificações feitas por eles, pontos fortes e fracos.

Nesta seção, discutir-se-á cinco dos principais protocolos e/ou padrões pesquisados que fazem uso de uma classificação de recursos e utilizam as estratégias supracitadas para representar sua hierarquia de recursos: UPnP, IEEE 1451, DLNA, USB, \emph{Bluetooth} e DDL.

\input{capitulos/2.FundamentacaoTeorica/classificacao/upnp}
\input{capitulos/2.FundamentacaoTeorica/classificacao/ieee1451}
\input{capitulos/2.FundamentacaoTeorica/classificacao/dlna}
\input{capitulos/2.FundamentacaoTeorica/classificacao/usb}
\input{capitulos/2.FundamentacaoTeorica/classificacao/bluetooth}
\input{capitulos/2.FundamentacaoTeorica/classificacao/ddl}

\subsection{Estado da Arte}
Nesta seção, apresentaremos alguns projetos de computação ubíqua e mostraremos como esses projetos tratam a classificação de recursos.

\input{capitulos/2.FundamentacaoTeorica/classificacao/gaia}
\input{capitulos/2.FundamentacaoTeorica/classificacao/amigo}
\input{capitulos/2.FundamentacaoTeorica/classificacao/gator}

\subsection{Comparativo}
%Apresentar um Comparativo entre as estratégias e conclusões que embasem a definição da proposição de vcs no capítulo seguinte.
Nesta seção faremos um comparativo dos padrões mostrados de forma a embasar a classificação de recursos que será proposta no próximo capítulo. A tabela~\ref{tab:comparativo} mostra uma comparação dos padrões quanto: à forma de classificação de recursos, à representação e extensibilidade dessa classificação e se um dispositivo pode fazer parte de mais de uma classe.

\begin{table}
	\caption{Comparativo dos Padrões.}
	\begin{center}
	\resizebox{16cm}{!} {
		\begin{tabular}{ccccccc}
		\hline
							& \textbf{IEEE 1451}	& \textbf{Bluetooth} 	& \textbf{USB}	& \textbf{UPnP} & \textbf{DLNA} & \textbf{DDL}\\
		\hline
		Classificação 		& Relacionada 			& Fixa 					& Relacionada 	& Relacionada 	& Relacionada 	& Fixa \\
		\hline
		Representação 		& IDL 					& Descritor				& Descritor		& XML			& XML 			& XML \\ 
		\hline
		Extensível 			& Não 					& Não 					& Sim 			& Sim 			& Sim 			& Não \\
		\hline
		Múltiplas Classes 	& Sim 					& Não					& Sim 			& Não 			& Sim 			& Não \\
		\hline
		\end{tabular}
	}
	\end{center}
	\label{tab:comparativo}
\end{table}
 
Como pode ser observado, os padrões existentes para a classificação de recursos mostrados neste trabalho são todos estruturados, ou seja, não foi utilizada uma forma dinâmica como uma ontologia para representar essa classificação. A tabela~\ref{tab:comparativo} mostra que a maioria dos padrões faz uso de uma classificação relacionada, pois possui a vantagem de aproveitar propriedades já definidas. Além disso, é comum a representação da classificação em arquivos XML, que embora seja um padrão independente de plataforma, tem a desvantagem de possuir uma relevante redundância de dados na sua formatação. Apesar da classificação de alguns padrões possuir a capacidade de ser extensível, é necessário que a nova classe criada pelos fabricantes de um dispositivo passe por uma homologação. Caso do UPnP. O USB, possui subclasses derivadas na sua especificação, entretanto não permite novas definições fora do padrão. Em geral, são pouco flexíveis. 

A tabela mostra ainda uma limitação da DDL (\emph{Device Description Language}), criada para reduzir a complexidade na definição de dispositivos via classes Java, pois, para cada dispositivo que não seja sensor ou atuador, se faz necessária a criação de uma nova classe para esse dispositivo complexo não relacionada com outras que já tenham sido criadas. Outro fator que impede o uso de subclasses é o fato de na definição do dispositivo, estarem definidos também seus serviços, modelados como operações. Se um dispositivo possuir apenas uma operação que receba parâmetros diferentes, por exemplo, a classe anteriormente definida não poderá ser reutilizada. 

\begin{table}
	\caption{Classes presentes nos padrões.}
	\begin{center}
		\begin{tabular}{|ccccc|}
		\hline
									& \textbf{Bluetooth} 	& \textbf{USB}	& \textbf{UPnP} & \textbf{DLNA}	\\
		\hline
		Áudio						& x						& x				& x 			& x				\\
		\hline
		Vídeo						& x						& x				& x				& x				\\
		\hline
		Servidor de mídia			& x						&				& x 			& x				\\
		\hline
		Tocador de mídia			& x						&				& x				& x				\\
		\hline
		Impressora 					& x						& x				& x				& x				\\
		\hline
		Imagem	 					& x						& x				& x				& x				\\
		\hline
		Scanner						& 						& x				& x				& 				\\
		\hline
		Armazenamento				&						& x				& 				& 				\\	
		\hline
		Telefone/PDAs				& x						& x				& x				& x				\\
		\hline
		Teclado						& x						& x				& 				& x				\\
		\hline
		Apontadores					& x						& x				& 				& x 			\\
		\hline
		Interface Humana		 	& x						& x				&  				&  				\\
		\hline
		Específico do fabricante 	& x 					& x				& x				& x				\\
		\hline								
		\end{tabular}
	\end{center}
	\label{tab:comparativoClasses}
\end{table}

A tabela~\ref{tab:comparativoClasses} mostra os principais dispositivos que possuem alguma classe associada nos padrões estudados. O padrão DDL não foi considerado no comparativo de classes devido sua classificação possuir apenas três categorias: sensores, atuadores e dispositivos complexos. Portanto, todos os dispositivos considerados neste comparativo poderiam se encaixar na última categoria. O padrão IEEE 1451 também não foi utilizado no comparativo, pois foi criado para facilitar a comunicação de transdutores, e suas classes não abrangem os dispositivos da tabela.

